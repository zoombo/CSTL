#pragma once

// Не работает. Но, мне кажется я понял почему...

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define byte unsigned char

struct TStack {
	int position; // Количество элементов в стеке.
	byte **data;  // Указатель на первый элемент массива_указателей_на_данные (массив_указателей на данные).
	int *lens;	  // Массив хранящий размеры данных на соответствующих позициях.
};

void TStack_init(struct TStack* this_s)
{
	// Инициализация структуры (конструктор).
	this_s->data = (byte**)calloc(1, sizeof(byte*)); // Выделяем память под массив_указателей_на_данные.
	this_s->position = 0;
	this_s->lens = calloc(1, sizeof(int));
}

void TStack_Push(struct TStack* this_s, void* in_unit, int len)
{
	// Добавляет элемент к стеку.
	int pos = this_s->position; // Просто для читаемости.
	*(this_s->data + pos) = malloc(len + 2); // Выделяем память для данных и указатель на эту память присваеваем соотв элементу.
	byte *mem = *(this_s->data + pos); // Для читаемости.
	//for (int i = 0; i < len; i++) {
	memcpy(mem, in_unit, len); // Копируем полученные от пользователя данные в память.
	//}
	*(this_s->lens + pos) = len; // Запоминаем длинну в массиве длинн.
	this_s->position++; /* Увеличиваем позицию. */
	// Увеличиваем размер массива_указателей_на_данные на один элемент.
	this_s->data = (byte**)realloc(this_s->data, (this_s->position + 1) * sizeof(byte*));
	// Увеличиваем массив хранящий размеры.
	this_s->lens = realloc(this_s->lens, (this_s->position + 1) * sizeof(int));

}

void* TStack_Pop(struct TStack* this_s) {

	this_s->position--;
	int pos = this_s->position;
	return *(this_s->data + pos);

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////



